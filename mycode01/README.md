## 4. 쿠버네티스 아키텍쳐 
![](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)
쿠버네티스는 홀수댓수의 마스터노드와 여러대의 워커노드로 구성된다.  
마스터는 컨트롤 플레인이라고도 부름  
책에서 보여주는 컴포넌트 apiserver,scheduler,controller-manager. kubelet, proxy 등은 마스터 노드에서 각각이 해당 컴포넌트를 실행하고, 컴포넌트들끼리 고가용성을 유지하기 위해 통신하고 있는 형태로 구현된다. 즉 마스터노드가 늘어나면 새로 붙은 마스터노드도 위의 컴포넌트를 각각 실행하고 다른 마스터노드와 통신한다.  
마스터노드가 홀수인 이유는 raft 알고리즘을 통해 리더 마스터노드가 장애로 죽었을때 새 리더를 선출하기 위해 투표를 참여하는데, 짝수일때는 과반을 만들기 어렵기 때문이라 한다. 단순히 생각해보자면 차이가 없을거같은데, 알고리즘의 간결함을 위해 그렇다 함.  

##### apiserver
쿠버네티스의 API를 제공하는 컴포넌트. 각 컴포넌트는 대부분 컨테이너로 동작하고 있다.  
kubectl을 통해 사용자가 명령을 쏘면 처리를 해주는 역할을 한다.(web ui로도 가능)  

##### etcd
쿠버네티스가 구동되며 필요한 데이터를 저장하는 kv 저장소.  

##### scheduler
팟을 생성하기 위해 워커노드를 감지하는 스케줄러.   
스케쥴링을 한다고 하면 약간 이상하게 들릴수 있지만 그러려니 하자.  
느낌이 잘 안온다면 자바에서 스레드를 이용하기 위해 스케쥴러를 부르는것을 생각하면 될듯.  
암튼 총합적으로 팟이 필요한 시스템 리소스나 데이터 지역성, 워크로드 간섭등을 판단해서 적절한 노드에 팟을 올리기 위한 컴포넌트이다.  

##### controller-manager 
파드를 실행시키기 위한 컨트롤러...를 컨트롤하는 매니저  
쿠버네티스는 ReplicaSet, Deployment, StatefulSet, DaemonSet 등의 컨트롤러를 지원하는데, 이런 컨트롤러의 상태를 모니터링하고 매니징하는 컴포넌트. 뭔말인지 모르겠지만 6장에 나옴   

##### kubelet 
마스터노드로부터 할당된 팟과 컨테이너를 매니징하기 위한 컴포넌트.  

##### proxy
네트워크 프록시,   
proxy 는 각 파드에게 외부트래픽을 전달하는 역할을 함.  
 
##### container runtime
컨테이너 런타임.   
실제로 컨테이너가 실행되기 위한 런타임이며, Docker도 그 런타임중 하나임.  
Docker, cri-o, containerd 등이 있음. 몇년전 Docker가 OCI라는 런타임 규격을 지키지 않아 문제가 있었음. shim 이라는 중간계층을 두어 docker를 지원하였으나, 치워버림. 현재는 Docker-engine을 통해 docker를 지원하는듯?  
디폴트는 containerd   

##### DNS
기본 dns가 있긴 하지만 확장성, 호환성등을 이유로 DNS애드온을 사용한다고 함.  
일반적인 DNS 기능을 쿠버네티스 환경에서 사용하기 위해 제공되는 듯  

##### ingress controller
ingress 를 지원하기 위한 컨트롤러.  
ingress 는 외부 트래픽을 내부 네트워크와 연결해주기 위해 사용되는 기능.  
라우팅 룰에 따라 서비스(내부 라우터)에게 전달해주는 역할을 함.  
![](https://d33wubrfki0l68.cloudfront.net/0e185f84ae43dcdc8952eb7d8f98c3eba87d2e3a/05337/ko/docs/images/ingress.svg)

---

### 오브젝트와 컨트롤러
쿠버네티스는 오브젝트와 컨트롤러가 있음  

아래는 오브젝트  
##### pod
쿠버네티스에서 실행되는 최소 단위. 격리되어있음.  
서비스를 구동하는데 사용되는 최소한의 단위. 독립적인 공간과 ip를 가지지만, 여러 이유에 의해 팟은 계속 사라졌다가 다시 뜨게 되므로 ip라는게 별 의미가 없음.  
한개의 팟에는 여러 컨테이너가 들어갈수 있지만 보통 하나의 팟에 하나의 컨테이너로 사용한다고 함.  

##### 네임스페이스
클러스터에서 사용되는 리소스들을 구분짓기 위한 관리 단위 그룹.  
디플로이먼트, 서비스, 파드 등에 적용되며, 노드같은 클러스터 범위의 오브젝트에는 적용되지 않음.  
디폴트가 있긴 하지만 관리측면에서는 네임스페이스를 사용하는것이 좋음.  

##### 볼륨 
다들 아시는 그냥 볼륨.  
팟은 계속 생성되고 사라지고가 컨트롤러에 의해 관리되므로 내부적으로 사용하는 디렉터리도 마찬가지로 임시적이므로 파드가 사라지더라도 사용할수 있어야함.  
그러기 위한 볼륨 오브젝트.  

##### 서비스
팟은 계속 생성되고 사라지고가 컨트롤러에 의해 관리되므로 접속 정보등이 고정되지 않음.   
ip를 알아야 할 필요가 없지만 반대로 그 정보가 고정되어 알수가 없다는 뜻.  
이 접속을 유지하기 위한 디스커버리 혹은 로드밸런서, 혹은 그 팟의 집합.  

##### 컨트롤러
클러스터 내 팟을 관리하고 사용자가 지정한 상태를 유지하기 위한 컴포넌트.  
지속적으로 팟을 모니터링하고, 팟에 관해 사용자의 명령을 수행함.  
몇가지 유형이 있음.  

---

### pod
앞에서 설명한대로 팟은 작업의 최소 단위.  
사실 더 작은 단위인 컨테이너가 존재하긴 하지만 쿠버네티스가 관리하는 최소 단위가 팟이고, 관리 측면에서 1개의 컨테이너 = 1개의 팟으로 이용한다고 함.(p126)  
해당 페이지 설명을 보면 하나의 파드안에 컨테이너를 여러개 넣은 상황에 대해 설명을 하는데,  
격리된 하나의 vm 이라고 생각하면 쉽게 이해할수 있을거같다.  
사실 우리가 aws 나 gcp에서 사용하는 컴퓨팅자원은 실제 머신이 아니라 vm이고, 아마 내부적으로는 쿠버네티스처럼 관리되고 있지 않을까 함.(그래서 잘 보면 공유 컴퓨팅 자원 이라고 명시함)  

q. 그렇다면 우리가 굳이 쿠버네티스를 통해 서비스를 제공할 필요는 없지 않느냐? 오히려 컴퓨팅 자원은 한정적인데 쿠버네티스 환경에 의해 손해를 보는게 아닌가?  
a. 맞음. 아이피에 의해 수동으로 디스커버리되는, 잦은 수평적 확장이 필요없는 환경에서는 굳이 쿠버네티스를 사용함으로 손해를 볼필요는 없음.   
하지만 나의 어플리케이션이 수평적으로 확장될 준비가 되어있고, 그런 요구(demand)가 있고, 마케팅 워드가 필요하다면 사용하면 됨.  

##### pod의 생명주기(giving life아님ㅎ)
팟은 생명 주기를 가지고 있고, `kubectl describe pods POD_NAME` 명령으로 확인 가능함.
상태는 다음과 같다.  
- pending
노드에 파드를 생성하는 도중. 아직 일을 하고있지는 않음. 컨테이너 이미지를 다운받는 과정을 포함함.  
- running
팟의 내부 컨테이너가 정상 동작중.   
- succeeded
정상 실행 종료.  
- failed
어떤 이유로 정상종료되지 않고 실패코드로 종료된 경우.  
- unknown
몰?루  
시스템이 파드의 상태를 확인할수없는 경우. 보통은 통신불량


##### probe
주기적으로 kubelet이 파드 안의 컨테이너 상태를 진단하여 컨테이너 재시작 혹은 종료 시킨다.  
프로브는 세가지를 소개하고 있는데, 이것도 자동은 아니다. yml에 정의 해야함.  
- liveness
컨테이너가 살아있는지 감지하는 프로브
- readness
컨테이너가 요청을 처리할수 있는 상태인지 감지하는 프로브
- startup
컨테이너가 시작되었는지 확인하는 프로브  
  
위 프로브들이 컨테이너를 확인하는 방법은 몇가지 있는데,
- Exec
컨테이너에 특정 명령을 실행시켜 확인
- TCP socket
특정 tcp 포트를 찔러보고 확인
- HTTP GET 
http 요청을 보내 200~400 이 나오는지 확인
- gRPG
gRPC를 사용하여 프로시저 호출, 응답이 SERVING인지 확인


##### 초기화 컨테이너
팟 내 나의 컨테이너가 실행되기 전에 실행되는 컨테이너.  
자바에서 객체 만들때 constructor 실행되는거라고 생각하면 될거같음.  
이걸 어따써? 라고 생각할수 있지만, 내가 구동할 어플리케이션이 먼저 필요한 파일이 용량이 큰게 있다면?  
컨테이너 이미지에 포함시키는 방법도 있으나, 파일이 바뀔때마다 이미지도 업데이트를 해야하고, 이를 보관하는것도 부담스럽다.  
이때 초기화 컨테이너를 이용하여 원하는 곳에서 파일을 받아오고 나의 어플리케이션을 수행시키는 방법등..  
만약, 초기화 컨테이너가 작업에 실패한다면 yml 설정에 따라 다르긴하지만 파드 작업 전체가 중지된다.


##### static pod
kubelet을 통해 직접 실행되는 파드가 있는데, 이를 스태틱 팟이라 부름. 주로 시스템쪽에 이용되는 파드다.  
kubelet에 의해 관리됨. apiserver를 거쳐 조종할수 없음.  


##### 자원 할당
pod도 결국은 노드위에서 동작하는거라, 고사양이 필요한 팟이 한 노드에 집중되면 문제가 발생함.  
스케줄러가 알아서 할당해주긴 하지만 기계적으로 처리되는거라 완벽하지 않음.   
yml 정의시 컨테이너가 어느정도의 자원을 사용할수 있는지 지정할수 있음.  
- .spec.containers[].resources.limits.cpu
시피유 한계량
- .spec.containers[].resources.limits.memory
메모리 한계량
- .spec.containers[].resources.requests.cpu
최소 cpu 자원 요구량
- .spec.containers[].resources.request.memory
최소 메모리 자원 요구량
만약, request 만큼의 여유자원이 있는 노드가 없다면 팟은 실행되지 못하고 pending상태로 쭉 대기하게 됨.  
limit 을 설정했기 때문에 오버커밋 상태가 발생할수있는데, 이 경우 우선순위가 낮은 컨테이너를 죽이고 필요하다면 팟을 다른 노드에 옮겨 실행할수도 있다고 한다.  
사용자 입장에선 아무 이유없이 파드가 죽었다고 생각할수도 있겠다.  
잘 모르겠다면 그냥 request와 limit을 동일하게 설정하라고 함.  


패턴은 뭔소린지도 모르겠으니 넘어갑니다.

---

### 컨트롤러 
팟를 직접 관리하는 것은 귀찮다. 노드에 장애가 생겼을때 내가 원하는 상태를 유지시키는것 또한 수동으로 해야하기 때문. 이럴거면 쿠버네티스를 쓸 이유가 없다.  
그렇기 때문에 관리를 해주는 컴포넌트가 필요한데, 이것이 컨트롤러.  
쿠버네티스에서는 팟의 관리목적으로 여러 컨트롤러를 지원함.  

대충 책을 읽었다는걸 가정하고 설명하자면
##### 상태 관리가 필요한 파드
스테이트풀 세트  
이름에서부터 상태에 관해 이야기함. 상태를 가지는 어플리케이션을 관리하기 위한 컨트롤러인데,  
영속성을 가지는 디비라던지 메시지 큐(볼륨사용), 혹은 파드의 고유성이 필요할때 사용한다.  
예를들면 IP로 직접 통신이 필요한경우(실제로 그렇다는 이야기가 아니라, 이름을 지정해야할때)  
같은일을 하는 어플리케이션이지만 각 어플리케이션마다 통신되는 목적지가 다른경우라거나.   
스테이트리스와 비교하면 이해가 쉬울듯   

##### 상태 유지를 하지 않아도 되는 파드
레플리케이션 컨트롤러(RC)  
레플리카 세트(RS)  
디플로이먼트  
rc는 쿠버네티스 초기부터 있던 기능이라 rs와 비슷하지만 이전버전에 가깝다.  
지정된 수의 레플리카를 생성하고 상태를 관리한다는 면에서는 비슷하지만 레플리카셋은 레이블 셀렉터를 이용할수 있다는 점에서 좀 더 유연하다. 특정레이블을 가진 파드만 확대/축소가 가능함.  
하지만 쿠버네티스 초기부터 있던 rc는 롤링업데이트 기능이 있지만, rs는 없음.   
아마 디플로이와 역할을 나누어 좀더 유연한 기능을 제공하려고 했던게 아닐지?  
디플로이먼트는 rs보다 좀 더 추상화된? 좀더 상위 개념이라고 볼수있을거같음.  
그냥 단순하게 rs에 배포와 롤아웃을 추가한 컨트롤러임.  
rs의 기능을 포함하고 있고, 스케일링과 배포에 관련된 롤아웃, 롤백 기능을 제공함.  

##### 클러스터 내부 공통처리를 위한 파드
데몬셋   
클러스터 내 모든 노드에 공통적으로 실행되어야하는 파드를 관리하는 컨트롤러  
노드마다 로그수집기, 시스템 리소스 모니터등이 여기에 포함된다.  

#### 일회성 작업을 위한 파드
잡  
크론잡  
잡은 aws ecs의 task라고 볼수 있을거같고, 크론잡은 잡에 cron을 이용하여 수행시키는 작업이다.  
잡의 종류는 단일잡, 병렬잡이 있다.  
단일잡은 말 그대로 단일작업을 수행하고 완료시키는 잡,  
잡 yml 정의시 completion에 1이상 넣으면 단일 잡을 차례로 수행하며, 정의한 수만큼 수행하고 끝남.  
병렬잡은 여러개의 파드로 이루어진 잡이다. yml 정의시 parallelism 값으로 동시성 정의가 가능함.  
말그대로 여러개 작업이 같이 수행됨.   
크론잡은 그냥 잡을 cron expression에 맞게 정의하면 컨트롤러가 해당 시간에 맞게 잡을 수행시켜줌.  
일반적으로 배치가 이런식으로 수행됨.  
deadlineSeconds 설정으로 수행제한시간을 설정할수 있음.  

